//Solution for https://adventofcode.com/2024/day/17 (Ctrl+Click in VS to follow link)

// In visual studio you can modify what input file will be loaded by going to Debug/Debug Properties
// and specifying its path and filename as a command line argument, e.g. "$(SolutionDir)input" 
// This value will be processed and passed to the built-in args[0] variable

// ** Your input: a list of register values and program opcodes/operands/parameters (see puzzle description)

string myInput = File.ReadAllText(args[0]).ReplaceLineEndings();

// ** Splitting and parsing the input:

string[] myInputSplit = myInput.Split(Environment.NewLine + Environment.NewLine);
//Get [RegisterA, valueA, registerB, valueB, etc]
string[] registerValuesAsString = myInputSplit[0].Split([":", Environment.NewLine], StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
//Get [Program, values]
string[] programAsString = myInputSplit[1].Split([":", Environment.NewLine], StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

//Fill the registers
long[] registers = new long[3];

for (int i = 0; i < registers.Length; i++)
{
    //1, 3, 5
	registers[i] = long.Parse(registerValuesAsString[1 + i * 2]);
}

//Get the program
int[] instructions = programAsString[1].Split(",").Select(int.Parse).ToArray();
int instructionPointer = 0;
bool debug = false;

// ** Part 1: Execute the program as provided and print the output

// First define some helper methods... (see the puzzle description)

long GetComboOperandValue(int pOperand)
{
	if (pOperand >= 0 && pOperand <= 3) return pOperand;
	if (pOperand >= 4 && pOperand <= 6) return registers[pOperand - 4];
	else throw new InvalidDataException("Invalid combo value encountered:" + pOperand);
}

int ExecuteInstruction(int instructionPointer, List<int> pOutput)
{
	int opcodei = instructions[instructionPointer];
	int operand = instructions[instructionPointer + 1];

	if (opcodei == 0)
	{
		registers[0] = (long)(registers[0] / Math.Pow(2, GetComboOperandValue(operand)));
		return instructionPointer + 2;
	}

	else if (opcodei == 1) 
	{
		registers[1] = (registers[1] ^ operand);
		return instructionPointer + 2;
	}

	else if (opcodei == 2) 
	{
		registers[1] = GetComboOperandValue(operand) % 8;
		return instructionPointer + 2;
	}

	else if (opcodei == 3) 
	{
		if (registers[0] == 0)
		{
			return instructionPointer + 2;
		}
		else
		{
			return operand;
		}
	}

	else if (opcodei == 4) 
	{
		registers[1] = (long)(registers[1] ^ registers[2]);
		return instructionPointer + 2;
	}

	else if (opcodei == 5) 
	{
		if (debug)
		{
            Console.WriteLine("A:" + registers[0] + " B:" + registers[1] + " => B%8:" + registers[1]%8);
            Console.ReadKey();
        }

        pOutput.Add((int) (GetComboOperandValue(operand) % 8));
		return instructionPointer + 2;
	}

	else if (opcodei == 6) 
	{
		registers[1] = (long)(registers[0] / Math.Pow(2, GetComboOperandValue(operand)));
		return instructionPointer + 2;
	}

	else if (opcodei == 7) 
	{
		registers[2] = (long)(registers[0] / Math.Pow(2, GetComboOperandValue(operand)));
		return instructionPointer + 2;
	}

	return int.MaxValue;
}

// Then a helper method to actually execute the whole program and return the results as a comma separated string

string RunProgram(long initialValue)
{
	instructionPointer = 0;

	registers[0] = initialValue;
	registers[1] = 0;
	registers[2] = 0;

    List<int> output = new();

	while (instructionPointer < instructions.Length)
	{
		instructionPointer = ExecuteInstruction(instructionPointer, output);

		if (instructionPointer == int.MaxValue)	break;
	}

    return string.Join(",", output);
}

Console.WriteLine("Part 1: " + RunProgram(registers[0]));

// ** Part 2: What should the initial value be to output a copy of the program?

// If we rerun part 1 with debugging on, we can see the output is a combination of what register A contains
// modified to result in some value in register B which is then moduloed with 8 and added to the output.
// After that the value in register A is divided by 8 (eg shifted 3 bits) and repeated as long as A > 0

// To figure out which register value A to start with to generate the given program as input,
// we are going to reverse engineer this value by basically starting with a register value of 0,
// running the program and see if the output is what we want...

// However since this would take forever, we do it a little bit smarter...
// Everytime we run the program we test if the end part of the program is matched
// and if so we multiply the current number with 8 and start increasing again,
// trying to match more of the program

// Seeing if we have a really high number the first output is generated by the last 3 bits, 
// the 2nd by the 2nd 3 bits .... etc etc until the last number is generated by the first 3 bits,
// we try to match the generated output with the END of our program, while shifting matching values to the left by 3 bits...

// Yep this one took me hours ;).

//debug = false;
long currentNumber = 0;
long offset = 0;

//The part after "Program:" in our input
string expectedResult = programAsString[1];

while (true)
{
	long numberToTest = currentNumber + offset;

	//Console.WriteLine("Testing:" + numberToTest + " == " + Convert.ToString(numberToTest, 2));

	string currentMatch = RunProgram(numberToTest);

	if (currentMatch == expectedResult)
	{
		//Console.ForegroundColor = ConsoleColor.Green;
		Console.WriteLine("Part 2: " + numberToTest);
		//Console.ResetColor();
		break;
	}

	if (expectedResult.EndsWith(currentMatch))
	{
		currentNumber = numberToTest << 3;
		//we offset++ at the end of the loop so we need to start at -1
		offset = -1;
		//Console.ForegroundColor = ConsoleColor.Green;
		//Console.WriteLine("Matched: " + currentMatch);
		//Console.ResetColor();
	}
	//else
	//{
	//	Console.WriteLine("Mismatch:\t" + currentMatch);
	//}

	offset++;
}
